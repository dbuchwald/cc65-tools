# First CC65 example

In last section I presented how `make` and `vasm` can be used to build Ben Eater's `blink.s` code. Now I want to demonstrate iteratively how to port the code to be compatible with CC65. The assumption (for now) is that the resulting ROM is identical to the one created by `vasm` from Ben's source, and this can be verified using the `make test` command for each of the subprojects.

Let's start with explaining few concepts first. Sorry for the lengthy introductions, but the idea is to make this tutorial accessible to everyone, even at the cost of increased verbosity.

## Some issues with `vasm` compilation

If you have ever used any proper development toolchain you might have noticed (even if that was hidden from you), that there are three distinct phases of building each binary:

1. Preprocessing - this is where your sources are initially parsed and all macros are replaced by their definitions, literals are replaced by their values and so on,
2. Compilation - raw sources (with all the macros expanded, literals replaced and so forth) are being compiled to machine code that is "location independent", meaning the resulting objects don't use specific addresses or direct references, but instead use "symbols" as placeholders for these entities,
3. Linking - objects generated by compiler are collected together, aligned in provided memory map according to target architecture specification and symbols are replaced by actual values calculated during this process.

Now, if this is first time you are reading about this, it might seem like gross overcomplication of things, but in fact there is a reason for all this.

Most notably you want your code to be compiled and linked separately, and there are two reasons for it:

1. For complex systems you might want to write different parts of your software in different programming languages, so you want each of these compiled by different compiler. In CC65 case you can use both 6502 assembly and C,
2. You might want to link various binaries from the same set of objects without the necessity to recompile them each time. Sure, for software built for 6502 CPU you can't expect too much gain in terms of compilation speed (after all, it will never take too long to compile code to fit in 64KB of memory), but this separation of concerns gives you much more security in building portable code.

Now, `vasm` is a good compiler targeting various architectures, but its macro processor is much less powerful than the one in CC65, linker is tied to compiler and it doesn't provide support for C code interoperability.

And this is just a very short list of problems I have with `vasm`...

## Firmware definition file

Now, I didn't include the above rant just to show off my (rather unimpressive) knowledge of compilers construction. The point was to explain why certain details we have to bother next are important, and where do they fit into the broader picture.

The first new thing you have to provide when building your code with CC65 is creating the firmware configuration file. You will find the simplest example in `cc65-tools-main/tutorial/02_blink` folder:

````
MEMORY
{
  ROM:       start=$8000, size=$8000, type=ro, define=yes, fill=yes,   fillval=$00, file=%O;
}

SEGMENTS
{
  CODE:      load=ROM,       type=ro,  define=yes;
  VECTORS:   load=ROM,       type=ro,  define=yes,   offset=$7ffa, optional=yes;
}
````

This is configuration file that describes your actual hardware build, and it already shows great concept behind CC65 - you don't need to change the code if you want to build and run your software on a different hardware configuration. Your address decoder is different than mine? Grab the code, change firmware configuration file and link the ROM again. You don't even have to recompile anything!

That being said, the above file might be intimidating with all the parameters and all. Don't worry, I will explain these in detail.

 