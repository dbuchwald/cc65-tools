# First CC65 example

In last section I presented how `make` and `vasm` can be used to build Ben Eater's `blink.s` code. Now I want to demonstrate iteratively how to port the code to be compatible with CC65. The assumption (for now) is that the resulting ROM is identical to the one created by `vasm` from Ben's source, and this can be verified using the `make test` command for each of the subprojects.

Let's start with explaining few concepts first. Sorry for the lengthy introductions, but the idea is to make this tutorial accessible to everyone, even at the cost of increased verbosity.

## Some issues with `vasm` compilation

If you have ever used any proper development toolchain you might have noticed (even if that was hidden from you), that there are three distinct phases of building each binary (or other build product):

1. Preprocessing - this is where your sources are initially parsed and all macros are replaced by their definitions, literals are replaced by their values and so on,
2. Compilation - raw sources (with all the macros expanded, literals replaced and so forth) are being compiled to machine code that is "location independent", meaning the resulting objects don't use specific addresses or direct references, but instead use "symbols" as placeholders for these entities. Please note: the target system architecture (Intel x86, 6502/65C02) is now fixed in this step,
3. Linking - objects generated by compiler are collected together, aligned in provided memory map according to target architecture specification and symbols are replaced by actual values calculated during this process.

Now, if this is first time you are reading about this, it might seem like gross overcomplication of things, but in fact there is a reason for all this.

Most notably you want your code to be compiled and linked separately, and there are two reasons for it:

1. For complex systems you might want to write different parts of your software in different programming languages, so you want each of these compiled by different compiler. In CC65 case you can use both 6502 assembly and C,
2. You might want to link various binaries from the same set of objects without the necessity to recompile them each time. Sure, for software built for 6502 CPU you can't expect too much gain in terms of compilation speed (after all, it will never take too long to compile code to fit in 64KB of memory), but this separation of concerns gives you much more security in building portable code.

Now, `vasm` is a good compiler targeting various architectures, but its macro processor is much less powerful than the one in CC65, linker is tied to compiler and it doesn't provide support for C code interoperability.

And this is just a very short list of problems I have with `vasm`...

## Firmware definition file

Now, I didn't include the above ramblings just to show off my (rather limited, to be honest) knowledge of compilers construction. The point was to explain why certain details we have to bother next are important, and where do they fit into the broader picture.

The first new thing you have to provide when building your code with CC65 is creating the firmware configuration file. You will find the simplest example in `cc65-tools-main/tutorial/02_blink` folder:

````
MEMORY
{
  ROM:       start=$8000, size=$8000, type=ro, define=yes, fill=yes,   fillval=$00, file=%O;
}

SEGMENTS
{
  CODE:      load=ROM,       type=ro,  define=yes;
  VECTORS:   load=ROM,       type=ro,  define=yes,   offset=$7ffa, optional=yes;
}
````

This is configuration file that describes your actual hardware build, and it already shows great concept behind CC65 - you don't need to change the code if you want to build and run your software on a different hardware configuration with different memory or I/O map. Your address decoder is different than mine? Grab the code, change firmware configuration file and link the ROM again. You don't even have to recompile anything!

That being said, the above file might be intimidating with all the parameters and all. Don't worry, I will explain these in detail.

First section covers memory areas. For now, since we don't intend to use RAM for anything at all, simple ROM location definition will suffice. The following parameters are used in `ROM` definition (please note: this is just a name, it has no meaning whatsoever):

- `start=$8000` is the starting address (hexadecimal) of the ROM space,
- `size=$8000` is the total size of this memory location. Linker will verify at link time if all the stuff you want to store there can fit in provided space,
- `type=ro` defines ROM space as read-only. Attempt to write to memory address represented by symbol located in that memory area will cause error at link time,
- `define=yes` will cause the linker to generate set of symbols representing various properties of this memory area like `__ROM_START__` or `__ROM_SIZE__`,
- `fill=yes` will cause the linker to fill unused part of this memory area with value specified in `fillval` option,
- `fillval=$00` defines value that will be used to fill unused memory areas,
- `file=%O` tells the linker to save the generated memory area to linked binary file.

Second section defines segments - actual usable, addressable areas, where the code and variables will be defined. There are some standard segments (like CODE, ZEROPAGE and BSS) which are to be used for specific purposes, but you can go ahead and change the names as you wish.

Let's look at the parameters used in segment definitions:

- `load=ROM` means that all the code and variables defined in that segment are to be located in ROM memory, and this `ROM` is the memory area defined above,
- `type=ro` means that all the data stored in this segment is read-only and any attempt to write to it should be treated as an error,
- `define=yes` will cause the linker to define set of symbols, like described above,
- `offset=$fffa` means that this particular segment is to be placed at byte 0xFFFA in `ROM` memory,
- `optional=yes` suppresses error if particular segment is not used in your sources. Sometimes you might want to skip certain segments and it's all fine.

To summarize, our firmware configuration file states that:

1. We have one memory area, starting at address `0x8000` of 32KB continuous read-only space that will be filled with `0x00` and saved to output file,
2. In that memory area we will have two read-only segments: first one will be called `code`, and linker itself will decide where to put it, and the second will be called `vectors` and placed at fixed offset of `0xFFFA`,
3. Linker will generate symbols for all memory areas and segments.

## Actual source code

Having the firmware configuration complete, we can go ahead and write the actual source code. You will find it in `cc65-tools-main/tutorial/02_blink/blink.s`:

````assembly
  .code

reset:
  lda #$ff
  sta $6002

  lda #$50
  sta $6000

loop:
  ror
  sta $6000

  jmp loop

  .segment "VECTORS"
  .word $0000
  .word reset
  .word $0000
````

As you can probably see, it's very similar to the code from Ben's example to be built by `vasm`. There are literally just two differences here. Instead of

```assembly
  .org $8000
```

We have now:

```assembly
  .code
```

The difference is obvious. In Ben's example we are telling the compiler exactly where in the memory should are code be located. For CC65 we are using different syntax - we are just simply telling the compiler that whatever machine code is generated here should be put in `CODE` segment, but it's up to linker to determine actual location.

Just for consistency, second difference is very similar, instead of:

```assembly
  .org $fffc
```

We have:

```assembly
  .segment "VECTORS"
```

And that's just it. Compiler will generate code (referring to undetermined value of `reset` label at this point), and linker will calculate actual `reset` location in memory after placing all objects in `code` segment.